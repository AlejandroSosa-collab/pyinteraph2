#!/usr/bin/python
# -*- coding: utf-8 -*-

#    PyInteraph, a software suite to analyze interactions and interaction network in structural ensembles.
#    Copyright (C) 2013 Matteo Tiberti <matteo.tiberti@gmail.com>, Gaetano Invernizzi, Yuval Inbar, 
#    Matteo Lambrughi, Gideon Schreiber, Â Elena Papaleo <elena.papaleo@unimib.it> <elena.papaleo@bio.ku.dk>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.

#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import

import argparse
import re
import logging

import numpy as np
from scipy.optimize import curve_fit
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
import networkx as nx

########################## HELPER FUNCTIONS ###########################

# Parametric sigmoid function for fitting
def sigmoid(x, x0, k, m, n): 
    y = m / (1 + np.exp(k*(x-x0))) + n
    return y

# Parametric analytic second derivative of sigmoid 
def seconddevsigmoid(x, x0, k, l, m): 
    y = \
        (k**2 * l * np.exp(k*(x+x0)) * (np.exp(k*x)-np.exp(k*x0)))  \
        / (np.exp(k*x0) + np.exp(k*x))**3    
    
    return y    

########################## ARGUMENT PARSER ############################

description = "Find persistence critical value"
parser = argparse.ArgumentParser(description = description)

d_helpstr = \
    ".dat file matrices (multiple: -d file.dat -d file2.dat ...)"
parser.add_argument("-d", "--input-dat", \
                    dest = "datfiles", \
                    help = d_helpstr, \
                    action = "append", \
                    default = None)

o_helpstr = "Output .dat file matrix"
parser.add_argument("-o", "--output-dat", \
                    dest = "out_dat", \
                    help = o_helpstr, \
                    action = "store", \
                    type = str, \
                    default = None)

c_helpstr = "Output clusters file"
parser.add_argument("-c", "--output-clusters", \
                    dest = "out_clusters", \
                    help = c_helpstr, \
                    action = "store", \
                    type = str, \
                    default = None)

t_default = 0.0
t_helpstr = \
    "Filter input matrices according to this threshold (default: {:f})"
parser.add_argument("-t", "--filter-threshold", \
                    dest = "filter", \
                    help = t_helpstr.format(t_default), \
                    type = float, \
                    default = t_default)

p_helpstr = "Plot clusters"
parser.add_argument("-p", "--plot", \
                    dest = "plot", \
                    action = "store_true", \
                    help = p_helpstr)

f_helpstr = \
    "Try to fit the plot to a sigmoid y = m / (1 + exp(k*(x-x0))) + n"
parser.add_argument("-f", "--fit", \
                    dest = "do_fit", \
                    help = f_helpstr, \
                    action = "store_true")

u_default = 100.0
u_helpstr = \
    "Maxium range value to be considered (default: {:f})"
parser.add_argument("-u", "--range-upper", \
                    dest = "upper", \
                    help = u_helpstr.format(u_default), \
                    type = float, \
                    default = u_default)

l_default = 0.0
l_helpstr = "Minimum range value to be considered (default: {:f})"
parser.add_argument("-l", "--range-lower", \
                    dest = "lower", \
                    help = l_helpstr.format(l_default), \
                    type = float, \
                    default = l_default)

s_default = 5.0
s_helpstr = \
    "Step range value to be considered (default: {:f})"
parser.add_argument("-s", "--range-step", \
                    dest = "step", \
                    help = s_helpstr.format(s_default), \
                    type = float, \
                    default = s_default)

w_helpstr = \
    "Use values in this matrix as weights for the output " \
    "adjacency matrix"
parser.add_argument("-w", "--weight-matrix", \
                    dest = "weights", \
                    help = w_helpstr, \
                    type = str)

x_default = 20.0
x_helpstr = \
    "Starting x0 parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-x", "--x0", \
                    dest = "x0", \
                    help = x_helpstr.format(x_default), \
                    type = float, \
                    default = x_default)

k_default = 2.0
k_helpstr = \
    "Starting k parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-k", \
                    dest = "k", \
                    help = k_helpstr.format(k_default),
                    type = float, \
                    default = k_default)

m_default = 20.0
m_helpstr = \
    "Starting m parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-m", \
                    dest = "m", \
                    help = m_helpstr.format(m_default), \
                    type = float, \
                    default = m_default)

n_default = 10.0
n_helpstr = \
    "Starting n parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-n", \
                    dest = "n", \
                    help = n_helpstr.format(n_default), \
                    type = float, \
                    default = n_default)

options = parser.parse_args()


########################### CHECK INPUTS ##############################

if options.datfiles is None:
    logging.error("Input file(s) must be provided.")
    exit(1)

if options.upper <= options.lower:
    logging.error("Maximum range value must be higher than minimum.")
    exit(1)

if options.step > (options.upper - options.lower):
    logstr = \
        "Step value must be lower than or equal to " \
        "[upper_value - lower_value]"
    logging.error(logstr)
    exit(1)

fnames = options.datfiles
matrices = []
for fname in fnames:
    try:
        matrix = np.loadtxt(fname)
        matrices.append(matrix)
    except:
        # catch numpy errors and include the traceback when
        # logging
        logstr = "Could not open file {:s}, or file in wrong format"
        logging.error(logstr.format(fname, exc_info = True))
        exit(1)

shapes = []
for matrix in matrices:  
    shapes.extend(matrix.shape)

if len(set(shapes)) != 1:
    logging.error("Matrices do not have the same shape.")
    exit(1)

for fname, matrix in zip(fnames, matrices):
    if matrix.shape[0] != matrix.shape[1]:
        logstr = "Matrix {:s} is not square"
        logging.error(logstr.format(fname))
        exit(1)
    if not np.allclose(matrix, matrix.T):
        logstr = "Matrix {:s} is not symmetric"
        logging.error(logstr.format(fname))
        exit(1)

    # all diagonal elements must be zero
    np.fill_diagonal(matrix, 0.0)


####################### MAXIMUM CLUSTER SIZES #########################

interval = np.arange(options.lower, options.upper, options.step)
maxclustsizes = []
for val in interval:
    # boolean matrices indicating where the original
    # matrices exceed val       
    boolmatrices = [matrix > val for matrix in matrices]
    # there will be only one boolean matrix if only one
    # input matrix was provided
    allmatrix = boolmatrices[0]
    if len(boolmatrices) > 1:
        # in case more there was more than one input matrix,
        # the final matrix will be a matrix resulting from an
        # element-wise logical OR applied to all matrices
        for i in range(1, len(boolmatrices)):
            allmatrix = np.logical_or(allmatrix, boolmatrices[i])

    # build a graph from the final boolean matrix
    G = nx.Graph(allmatrix)
    # get the maximum cluster size from the graph
    maxclustsizes.append(\
        len(max(list(\
            nx.algorithms.components.connected_components(G)), \
        key = len)))


############################## FITTING ################################

x = interval
y = maxclustsizes
args = None
flex = None

if options.do_fit:
    logging.info("""Fitting data points to functional form: y = l / (1 + exp(k*(x-x0))) + m
Starting parameters:
    x0 = %3.2f 
    k =  %3.2f 
    m =  %3.2f  
    n =  %3.2f""" % (options.x0, options.k, options.m, options.n))

    try:
        popt, pcov = curve_fit(sigmoid, x, y, maxfev=100000, p0=(options.x0, options.k, options.m, options.n) )
        args=(popt[0],popt[1],popt[2],popt[3])
    except:
        logging.error("could not complete fitting.")
        args = None

    flex = None
    if args:
        logging.info("""
Done!
Calculated parameters: 
    x0 = %3.5f
    k  = %3.5f
    l  = %3.5f
    m  = %3.5f""" % (args[0],args[1],args[2],args[3]))

        logging.info("Looking for central point of inflection (f''(x) = 0) ...")

        solvestart = options.x0

        logging.info("Starting from: %3.5f ..." % solvestart) 

        try:
           flex = fsolve(seconddevsigmoid,solvestart,args=args,maxfev=5000)    
        except:
           flex = None

        if flex:
            print "Flexus point at %3.2f" % flex

if options.plot:
    plt.plot(x, y, 'o')

    plt.xlim((options.lower, options.upper))
    plt.xlabel("$p_{min}$")
    plt.ylabel("Size of the biggest cluster")
    if args:
        xplot = np.linspace(max(x),min(x))
        yplot = sigmoid(xplot, *popt)
        plt.plot(xplot, yplot, label='Fitting')
         
    if flex:
        plt.plot(flex,sigmoid(flex,*popt),'o',label = 'Critical value', color = 'red')
        plt.axvline(x=flex)

    plt.legend(loc='best')
    plt.savefig(options.plot)

if options.out_clusters:
    try:
        fh = open(options.out_clusters, 'w')
        fh.write("P_min\tSize of biggest cluster\n")
    except:
        logging.error("Could not write clusters file.")
    exit(1)
    for i, xi in enumerate(x):
        fh.write("%.3f\t%d\n" % (xi, y[i]))
    fh.close()

if options.out_dat:
    if len(matrices) == 1:         
        mask = matrices[0] <= options.filter
        out_matrix = np.ma.masked_array(data=matrices[0], mask = mask, fill_value=0.0).filled()
    else:
        boolmats = [i > options.filter for i in matrices]
        out_matrix = boolmats[0]
        for i in range (1,len(boolmats)):
            out_matrix = np.logical_or(out_matrix, boolmats[i])
    if options.weights:
        try:
            weights = np.loadtxt(options.weights)
        except:
            logging.error("Could not read weights matrix.")
            exit()
         
        if weights.shape != out_matrix.shape:
            logging.error("Output and weight matrix have different shapes.")

        np.savetxt(options.out_dat, np.ma.masked_array(data=weights, mask=out_matrix > 0.0, fill_value = 0.0).filled(), fmt="%3.2f")

    else:
        np.savetxt(options.out_dat, out_matrix,fmt="%3.2f")
