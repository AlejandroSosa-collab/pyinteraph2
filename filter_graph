#!/usr/bin/python
# -*- coding: utf-8 -*-

#    PyInteraph, a software suite to analyze interactions and interaction network in structural ensembles.
#    Copyright (C) 2013 Matteo Tiberti <matteo.tiberti@gmail.com>, Gaetano Invernizzi, Yuval Inbar, 
#    Matteo Lambrughi, Gideon Schreiber, Â Elena Papaleo <elena.papaleo@unimib.it> <elena.papaleo@bio.ku.dk>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.

#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import

import argparse
import re
import logging

import numpy as np
from scipy.optimize import curve_fit
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
import networkx as nx

########################## HELPER FUNCTIONS ###########################

# Parametric sigmoid function for fitting
def sigmoid(x, x0, k, m, n): 
    y = m / (1 + np.exp(k*(x-x0))) + n
    return y

# Parametric analytic second derivative of sigmoid 
def seconddevsigmoid(x, x0, k, l, m): 
    y = \
        (k**2 * l * np.exp(k*(x+x0)) * (np.exp(k*x)-np.exp(k*x0)))  \
        / (np.exp(k*x0) + np.exp(k*x))**3    
    
    return y    

########################## ARGUMENT PARSER ############################

description = "Find persistence critical value"
parser = argparse.ArgumentParser(description = description)

d_helpstr = \
    ".dat file matrices (multiple: -d file.dat -d file2.dat ...)"
parser.add_argument("-d", "--input-dat", \
                    dest = "datfiles", \
                    help = d_helpstr, \
                    action = "append", \
                    default = None)

o_helpstr = "Output .dat file matrix"
parser.add_argument("-o", "--output-dat", \
                    dest = "out_dat", \
                    help = o_helpstr, \
                    action = "store", \
                    type = str, \
                    default = None)

c_helpstr = "Output clusters file"
parser.add_argument("-c", "--output-clusters", \
                    dest = "out_clusters", \
                    help = c_helpstr, \
                    action = "store", \
                    type = str, \
                    default = None)

t_default = 0.0
t_helpstr = \
    "Filter input matrices according to this threshold (default: {:f})"
parser.add_argument("-t", "--filter-threshold", \
                    dest = "filter", \
                    help = t_helpstr.format(t_default), \
                    type = float, \
                    default = t_default)

p_helpstr = "Name of the file where to plot clusters"
parser.add_argument("-p", "--plot", \
                    dest = "out_plot", \
                    help = p_helpstr, \
                    default = None)

f_helpstr = \
    "Try to fit the plot to a sigmoid y = m / (1 + exp(k*(x-x0))) + n"
parser.add_argument("-f", "--fit", \
                    dest = "do_fit", \
                    help = f_helpstr, \
                    action = "store_true")

u_default = 100.0
u_helpstr = \
    "Maxium range value to be considered (default: {:f})"
parser.add_argument("-u", "--range-upper", \
                    dest = "upper", \
                    help = u_helpstr.format(u_default), \
                    type = float, \
                    default = u_default)

l_default = 0.0
l_helpstr = "Minimum range value to be considered (default: {:f})"
parser.add_argument("-l", "--range-lower", \
                    dest = "lower", \
                    help = l_helpstr.format(l_default), \
                    type = float, \
                    default = l_default)

s_default = 5.0
s_helpstr = \
    "Step range value to be considered (default: {:f})"
parser.add_argument("-s", "--range-step", \
                    dest = "step", \
                    help = s_helpstr.format(s_default), \
                    type = float, \
                    default = s_default)

w_helpstr = \
    "Use values in this matrix as weights for the output " \
    "adjacency matrix"
parser.add_argument("-w", "--weight-matrix", \
                    dest = "weights", \
                    help = w_helpstr, \
                    type = str)

x_default = 20.0
x_helpstr = \
    "Starting x0 parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-x", "--x0", \
                    dest = "x0", \
                    help = x_helpstr.format(x_default), \
                    type = float, \
                    default = x_default)

k_default = 2.0
k_helpstr = \
    "Starting k parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-k", \
                    dest = "k", \
                    help = k_helpstr.format(k_default),
                    type = float, \
                    default = k_default)

m_default = 20.0
m_helpstr = \
    "Starting m parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-m", \
                    dest = "m", \
                    help = m_helpstr.format(m_default), \
                    type = float, \
                    default = m_default)

n_default = 10.0
n_helpstr = \
    "Starting n parameter for sigmoid fitting (default: {:f})"
parser.add_argument("-n", \
                    dest = "n", \
                    help = n_helpstr.format(n_default), \
                    type = float, \
                    default = n_default)

options = parser.parse_args()


########################### CHECK INPUTS ##############################

if options.datfiles is None:
    logging.error("Input file(s) must be provided.")
    exit(1)

if options.upper <= options.lower:
    logging.error("Maximum range value must be higher than minimum.")
    exit(1)

if options.step > (options.upper - options.lower):
    logstr = \
        "Step value must be lower than or equal to " \
        "[upper_value - lower_value]"
    logging.error(logstr)
    exit(1)

fnames = options.datfiles
matrices = []
for fname in fnames:
    try:
        matrix = np.loadtxt(fname)
        matrices.append(matrix)
    except:
        # catch numpy errors and include the traceback when
        # logging
        logstr = "Could not open file {:s}, or file in wrong format"
        logging.error(logstr.format(fname, exc_info = True))
        exit(1)

shapes = []
for matrix in matrices:  
    shapes.extend(matrix.shape)

if len(set(shapes)) != 1:
    logging.error("Matrices do not have the same shape.")
    exit(1)

for fname, matrix in zip(fnames, matrices):
    if matrix.shape[0] != matrix.shape[1]:
        logstr = "Matrix {:s} is not square"
        logging.error(logstr.format(fname))
        exit(1)
    if not np.allclose(matrix, matrix.T):
        logstr = "Matrix {:s} is not symmetric"
        logging.error(logstr.format(fname))
        exit(1)

    # all diagonal elements must be zero
    np.fill_diagonal(matrix, 0.0)


####################### MAXIMUM CLUSTER SIZES #########################

interval = np.arange(options.lower, options.upper, options.step)
maxclustsizes = []
for val in interval:
    # boolean matrices indicating where the original
    # matrices exceed val       
    boolmatrices = [matrix > val for matrix in matrices]
    # there will be only one boolean matrix if only one
    # input matrix was provided
    allmatrix = boolmatrices[0]
    if len(boolmatrices) > 1:
        # in case more there was more than one input matrix,
        # the final matrix will be a matrix resulting from an
        # element-wise logical OR applied to all matrices
        for i in range(1, len(boolmatrices)):
            allmatrix = np.logical_or(allmatrix, boolmatrices[i])

    # build a graph from the final boolean matrix
    G = nx.Graph(allmatrix)
    # get the maximum cluster size from the graph
    maxclustsizes.append(\
        len(max(list(\
            nx.algorithms.components.connected_components(G)), \
        key = len)))


############################## FITTING ################################

x = interval
y = maxclustsizes
args = None
flex = None

if options.do_fit:
    logstr = \
        '"""\nFitting data points to functional form: ' \
        'y = m / (1 + exp(k*(x-x0))) + n\nStarting parameters:\n' \
        'x0 = {:3.2f}\nk =  {:3.2f}\nm =  {:3.2f}\nn =  {:3.2f}\n"""'
    logging.info(\
        logstr.format(options.x0, options.k, options.m, options.n))

    # will be None unless the fitting completes successfully
    args = None
    try:
        popt, pcov = \
            curve_fit(f = sigmoid, \
                      xdata = x, \
                      ydata = y, \
                      maxfev = 100000, \
                      p0 = (options.x0, options.k, options.m, options.n))
        
        args = (popt[0], popt[1], popt[2], popt[3])
    
    except ValueError:
        # as per scipy.optimize.curve_fit documentation
        logging.error(\
            "Please check input data and options provided for " \
            "the fitting", \
            exc_info = True)

    except RuntimeError:
        # as per scipy.optimize.curve_fit documentation
        logging.error(\
            "Could not complete fitting since the least-squares ", \
            "minimization failed"
            exc_info = True)

    except:
        # something else happened (should not happen)
        logging.error(\
            "Could not complete fitting", \
            exc_info = True)


    ####################### SECOND DERIVATIVE #########################
    
    if args is not None:
        logstr = \
            '"""\nDone! Calculated parameters:\nx0 = {:3.5f}\n' \
            'k  = {:3.5f}\nl  = {:3.5f}\nm  = {:3.5f}\n"""'
        logging.info(logstr.format(*args))

        logging.info(\
            "Looking for central point of inflection (f''(x) = 0) ...")

        solvestart = options.x0
        logging.info("Starting from: {:3.5f} ...".format(solvestart))

        # will be None unless the calculation completes successfully
        flex = None
        try:
           flex = fsolve(func = seconddevsigmoid, \
                         x0 = solvestart, \
                         args = args, \
                         maxfev = 5000)    
        except:
            # inform the user that something went wrong during
            # the calculation and include traceback
            logging.error(\
                "Could not complete the calculation", \
                exc_info = True)

        if flex is not None:
            logging.info("Flexus point at {:3.2f}".format(flex))


############################## PLOTTING ###############################

if options.out_plot is not None:
    plt.plot(x = x, y = y, fmt = "o")
    plt.xlim((options.lower, options.upper))
    plt.xlabel("$p_{min}$")
    plt.ylabel("Size of the biggest cluster")
    
    if args is not None:
        xplot = np.linspace(max(x), min(x))
        yplot = sigmoid(xplot, *popt)
        plt.plot(x = xplot, y = yplot, label = "Fitting")
         
    if flex is not None:
        plt.plot(x = flex, \
                 y = sigmoid(flex, *popt),\
                 fmt = "o", \
                 label = "Critical value", \
                 color = "red")
        
        plt.axvline(x = flex)

    plt.legend(loc = "best")
    plt.savefig(options.out_plot)


if options.out_clusters is not None:
    try:
        fh = open(options.out_clusters, 'w')
        fh.write("P_min\tSize of biggest cluster\n")
    except:
        logging.error("Could not write clusters file.")
    exit(1)
    for i, xi in enumerate(x):
        fh.write("%.3f\t%d\n" % (xi, y[i]))
    fh.close()

if options.out_dat is not None:
    if len(matrices) == 1:         
        mask = matrices[0] <= options.filter
        out_matrix = np.ma.masked_array(data=matrices[0], mask = mask, fill_value=0.0).filled()
    else:
        boolmats = [i > options.filter for i in matrices]
        out_matrix = boolmats[0]
        for i in range (1,len(boolmats)):
            out_matrix = np.logical_or(out_matrix, boolmats[i])
    if options.weights:
        try:
            weights = np.loadtxt(options.weights)
        except:
            logging.error("Could not read weights matrix.")
            exit()
         
        if weights.shape != out_matrix.shape:
            logging.error("Output and weight matrix have different shapes.")

        np.savetxt(options.out_dat, np.ma.masked_array(data=weights, mask=out_matrix > 0.0, fill_value = 0.0).filled(), fmt="%3.2f")

    else:
        np.savetxt(options.out_dat, out_matrix,fmt="%3.2f")
